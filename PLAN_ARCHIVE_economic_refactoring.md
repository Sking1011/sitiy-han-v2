# План рефакторинга экономической модели: Переход на строгий партионный учет (FIFO)

**Дата:** 14 февраля 2026 г.
**Статус:** Черновик / План к исполнению
**Цель:** Внедрение профессиональных стандартов учета себестоимости (GAAP/IFRS) для устранения финансовых искажений.

---

## 1. Введение и Обоснование

### 1.1. Текущая проблема
В данный момент система `Sitiy Han v2` использует гибридную модель учета:
1.  **Физический уровень:** Мы храним Партии (`Batch`) и списываем их по FIFO (или вручную). Это верно.
2.  **Финансовый уровень:** При расчете себестоимости производства (`Production`) система опирается на поле `Product.averagePurchasePrice` (скользящая средняя).

**Почему это критически неверно:**
*   **Искажение прибыли:** Скользящая средняя «сглаживает» скачки цен. Если мясо подорожало на 30%, а мы используем старые запасы, средняя цена сразу вырастет, и мы завысим себестоимость старого мяса, занизив прибыль текущего периода.
*   **Разрыв данных:** Фронтенд рассчитывает стоимость `X`, пользователь видит `X`, сохраняет. Бэкенд списывает партии, у которых реальная стоимость `Y`. Разница (`X - Y`) исчезает в никуда, создавая «фантомные» прибыли или убытки, которые невозможно отследить в аудите.
*   **Специи и Расходники:** Для них сейчас вообще не выбираются партии, берется «средняя по больнице».

### 1.2. Целевое состояние (To-Be)
Мы переходим на модель **Strict Batch Accounting (Строгий Партионный Учет)**.

**Аксиомы новой системы:**
1.  **Цена неотделима от Партии.** Не существует абстрактной «цены товара». Есть только «цена конкретной партии».
2.  **Себестоимость — это факт, а не план.** Себестоимость готовой продукции рассчитывается **исключительно** на Бэкенде в момент транзакции (списания), на основе реально затронутых партий.
3.  **Принцип FIFO для автоматики.** Если партия не выбрана вручную (специи), система списывает строго по хронологии (First-In, First-Out) и берет цены списываемых партий.
4.  **Traceability (Прослеживаемость).** Мы должны знать, что палка колбасы #505 состоит из:
    *   Говядины (Партия #101, 1200тг/кг)
    *   Соли (Партия #30, 80тг/кг)
    *   Перца (Партия #12, 5000тг/кг)
    *   Итоговая себестоимость = Сумма реальных затрат.

---

## 2. Техническое описание изменений

### 2.1. Изменения в Базе Данных (Prisma Schema)

Нам не нужно кардинально ломать схему, но нужно изменить семантику использования полей.

1.  **`Product`**:
    *   Поле `averagePurchasePrice` переводится в статус **"Reference Only"** (Справочно). Оно больше не участвует в финансовых расчетах транзакций. Используется только для быстрой оценки на дашборде.
    
2.  **`ProductionMaterial`** (Сырье в производстве):
    *   Поле `batchId` становится **обязательным** (логически). Даже если пользователь не выбрал партию, Бэкенд *обязан* найти партии по FIFO и создать записи `ProductionMaterial` для каждой затронутой партии.
    *   *Пример:* Если на варку ушло 1.5 кг соли, а у нас есть партии по 1 кг, то в `ProductionMaterial` должно появиться **две** записи (или одна агрегированная, но ссылающаяся на точные цены - *см. нюанс ниже*).
    *   **Решение:** Оставляем связь `batchId` опциональной в БД, но добавляем поля snapshot-цены.
    
    ```prisma
    model ProductionMaterial {
      // ... id, productionId, productId ...
      
      quantityUsed Decimal
      
      // Ссылка на партию (может быть null, если списали "в минус", что плохо, но бывает)
      batchId      String? 
      batch        Batch? @relation(...)

      // НОВОЕ: Фиксация цены момента списания
      priceAtMoment Decimal @db.Decimal(10, 2) // Цена за единицу из этой партии
      totalCost     Decimal @db.Decimal(12, 2) // quantityUsed * priceAtMoment
    }
    ```

3.  **`ProductionItem`** (Готовый продукт):
    *   Поле `calculatedCostPerUnit` теперь результат сложения всех `ProductionMaterial.totalCost` / `quantityProduced`.

### 2.2. Алгоритм Расчета Себестоимости (The Core Algorithm)

Этот алгоритм должен быть реализован в `ProductionService` (или новом `CostingService`).

#### Функция `calculateAndDeductMaterials(tx, materialsNeeded)`

**Входные данные:**
*   Список материалов: `[{ productId: 'salt', quantity: 1.5 }, { productId: 'meat', quantity: 10, batchId: 'specific-batch-1' }]`

**Логика:**
1.  **Итерация по материалам:**
    *   Если указан `batchId` (Ручной выбор):
        *   Находим партию. Проверяем остаток.
        *   Списываем.
        *   Фиксируем: `Cost += quantity * batch.pricePerUnit`.
        *   Создаем `ProductionMaterial` с привязкой к `batchId` и `priceAtMoment`.
    *   Если `batchId` НЕ указан (Авто-FIFO):
        *   Запрашиваем активные партии товара (`remainingQuantity > 0`), сорт `createdAt ASC`.
        *   **Цикл списания (The Bucket Logic):**
            *   Пока `needed > 0`:
                *   Берем текущую партию.
                *   `take = Math.min(batch.remaining, needed)`
                *   `needed -= take`
                *   `batch.remaining -= take`
                *   `Cost += take * batch.pricePerUnit`
                *   Создаем `ProductionMaterial` для этого кусочка списания.
        *   *Edge Case:* Если партий не хватило (ушли в минус)?
            *   Списываем остаток "в воздух" (или в дефолтную партию).
            *   Цену берем из `Product.lastPurchasePrice` или `Product.averagePurchasePrice` как фоллбэк. Логируем WARN.

**Выход:**
*   Созданные записи `ProductionMaterial`.
*   Общая сумма затрат (`TotalProductionCost`).

---

## 3. Рефакторинг Frontend (UX)

Пользователь больше не должен видеть "фиксированную" цену ингредиента до момента сохранения, либо должен видеть четкую надпись "Прогноз".

### 3.1. Карточка Производства
1.  **Выбор ингредиентов:**
    *   Убираем использование `product.averagePurchasePrice` как истины.
    *   Для специй показываем: `~ 1500 ₸ (Расчетная)`. Можно сделать асинхронный запрос на бэкенд "Simulate Cost", чтобы показать точную цифру по текущему FIFO.
    
2.  **Завершение производства:**
    *   Кнопка "Завершить" отправляет только количества и IDs. Цены не отправляются (или игнорируются бэкендом).
    *   После завершения UI обновляется и показывает **фактическую** себестоимость, рассчитанную сервером.

---

## 4. План реализации (Step-by-Step)

### Фаза 1: Подготовка Бэкенда
1.  Создать утилиту `CostCalculator` в `lib/`.
2.  Реализовать метод `simulateFifoCost(items: {productId, qty}[])` -> возвращает прогноз стоимости.
3.  Модифицировать `InventoryService.deductStock`:
    *   Метод должен не просто уменьшать цифры, а возвращать структуру: `Array<{ batchId, quantityTaken, pricePerUnit }>`.

### Фаза 2: Миграция Данных (Опционально)
*   Если мы добавляем поля `priceAtMoment` в `ProductionMaterial`, нужно заполнить их для старых записей (исторических), используя `averagePurchasePrice` тех времен или текущую. Для начала можно сделать поле nullable.

### Фаза 3: Обновление `ProductionService`
*   Переписать метод `createProduction` и `updateProduction`.
*   Внедрить логику "Расщепления" (Splitting). Если для покрытия потребности в 1.5 кг соли нужно 2 партии, создаем **две** записи в `ProductionMaterial` (или одну агрегированную, но лучше две для точности аудита).
    *   *Альтернатива:* Одна запись `ProductionMaterial`, но поле `cost` считается точно. Выберем этот вариант, чтобы не захламлять UI сотнями записей о пакетиках перца.
    *   **Уточненная логика:** Одна запись `ProductionMaterial` на один `Product`. Поле `totalCost` хранит сумму по всем затронутым партиям. Поле `batchId` хранит ID *основной* партии (наибольшей) или `null` (если сборная солянка), а в JSON-поле `details` (надо добавить) пишем полный расклад `[{batchId, qty, price}, ...]`.

### Фаза 4: Адаптация UI
*   В `ProductionClient.tsx`:
    *   Заменить прямую математику `qty * price` на отображение статуса "Ожидание расчета" или предварительный расчет.
    *   При загрузке истории брать `calculatedCostPerUnit` с сервера, а не пересчитывать на клиенте.

---

## 5. Детальные сценарии (Edge Cases)

### 5.1. Списание в минус (Negative Stock)
*   **Ситуация:** По системе 0 кг соли. Повар берет 1 кг (забыл внести закуп).
*   **Действие:**
    *   Разрешаем списание (бизнес не должен стоять).
    *   `Product.currentStock` становится -1.
    *   **Цена:** Какую цену брать?
    *   **Решение:** Брать `lastPurchasePrice` (цену последней закупки) из истории `ProcurementItem`. Если истории нет — 0.
    *   Помечаем транзакцию флагом `IsEstimated: true` (если добавим такой функционал в будущем).

### 5.2. Редактирование задним числом
*   **Ситуация:** Производство завершено вчера. Сегодня поменяли количество мяса.
*   **Действие:**
    *   Это сложная операция. Нужно "вернуть" списанные партии (отменить `deduct`), и списать заново новые количества.
    *   При возврате (`revert`) возвращаем количество в те же партии, откуда взяли (нужна история списаний в `ProductionMaterial` с разбивкой по батчам).

---

## 6. Пример расчета (Математическая модель)

**Дано:**
*   Партия А (Соль): 0.5 кг @ 100 тг/кг
*   Партия Б (Соль): 2.0 кг @ 200 тг/кг

**Задача:** Списать 1.5 кг соли.

**Расчет (Backend):**
1.  Нужно 1.5 кг.
2.  Берем Партию А: Доступно 0.5. Списываем 0.5. Стоимость += 0.5 * 100 = 50. Остаток потребности = 1.0.
3.  Берем Партию Б: Доступно 2.0. Списываем 1.0. Стоимость += 1.0 * 200 = 200. Остаток потребности = 0.
4.  **Итого:**
    *   Вес: 1.5 кг.
    *   Стоимость: 50 + 200 = 250 тг.
    *   Средняя цена списания: 250 / 1.5 = 166.66 тг/кг.
    *   (Старый метод мог показать 200 или 100, в зависимости от средней).

---

## 7. Чек-лист перед внедрением

1.  [ ] Бэкап базы данных.
2.  [ ] Добавление поля `cost` в `ProductionMaterial` (если нет).
3.  [ ] Реализация сервиса FIFO калькуляции.
4.  [ ] Тесты на юнит-уровне (сценарии с разными ценами).
5.  [ ] Обновление UI для отображения реальной себестоимости.

Этот план обеспечивает переход к точной финансовой модели, где каждый тиын учтен и привязан к конкретной закупке.
